% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/SimulAnne_optim_tdv.R
\name{SimulAnne_optim_tdv}
\alias{SimulAnne_optim_tdv}
\title{Total Differential Value optimization using a simulated annealing (and GRASP) algorithm(s)}
\usage{
SimulAnne_optim_tdv(
  m,
  k,
  p.initial = NULL,
  n.runs = 10,
  n.sol = 5,
  T_inic = 0.3,
  T_final = 1e-06,
  alpha = 0.05,
  n.iter = 1000,
  use.GRASP = TRUE,
  thr = 0.95,
  full.output = FALSE
)
}
\arguments{
\item{m}{A \code{matrix}, i.e. a phytosociological table of 0s (absences) and 1s (presences), where rows correspond to taxa and columns correspond to relevés.}

\item{k}{A \code{numeric} giving the number of desired groups.}

\item{p.initial}{A \code{vector} of integer numbers with the partition of the relevés (i.e. a \code{k}-partition, consisting in a vector with values from 1 to k, with length equal to the number of columns of m, ascribing each relevé to one of the k groups), to be used as initial partition in the simulated annealing. For a random partition use \code{p.initial = "random"}. This argument is ignored if \code{use.GRASP = TRUE}.}

\item{n.runs}{A \code{numeric} giving the number of runs. Defaults to 10.}

\item{n.sol}{A \code{numeric}, giving the number of best solutions to keep in the final output (only used if \code{full.output} is \code{FALSE}; if \code{full.output} is \code{TRUE} all runs will produce an output). Defaults to 5.}

\item{T_inic}{A \code{numeric} giving the initial temperature. Must be greater than 0 and maximum admitted value is 1. Defaults to 0.3.}

\item{T_final}{A \code{numeric} giving the initial temperature. Must be bounded between 0 and 1. Usually very low values are needed to ensure convergence. Defaults to 0.000001.}

\item{alpha}{A \code{numeric} giving the fraction of temperature drop to be used in the temperature reduction scheme (see Details). Must be bounded between 0 and 1. Defaults to 0.05.}

\item{n.iter}{A \code{numeric} giving the initial temperature. Defaults to 1000}

\item{use.GRASP}{A \code{logical}. Defaults to \code{TRUE}. IF \code{TRUE}, a GRASP is used to obtain the initial partitions for the simulated annealing. If \code{FALSE} the user should provide an initial partition or use or use \code{p.initial = "random"} for a random one.}

\item{thr}{A \code{numeric} giving a threshold value (from 0 to 1 ) with the probability used to compute the sample quantile, in order to get the best \code{m} columns from which to select one to be include in the GRASP solution (in each step of the procedure). Only needed if \code{use.GRASP} is \code{TRUE}.}

\item{full.output}{A \code{logical}. Defaults to \code{FALSE}. IF \code{TRUE} extra information is presented in the output. See Value.}
}
\value{
If \code{full.output = FALSE} (the default), a \code{list} with the following components (the GRASP component is only returned if \code{use.GRASP = TRUE}):

\describe{
\item{GRASP}{A \code{list} with at most \code{n.sol} components, each one containing also a \code{list} with two components:
\itemize{
\item{'par', containing the partition obtained by GRASP;}
\item{'tdv', with the value of TDV of the above partition.}
}
}
\item{SANN}{A \code{list} with at most \code{n.sol} components, each one containing also a \code{list} with two components:
\itemize{
\item{'par', containing the partition with highest value of TDV, obtained by the SANN algorithm;}
\item{'tdv', with the value of TDV of the above partition.}
}
}
}

If \code{full.output = TRUE}, a \code{list} with the following components (the GRASP component is only returned if \code{use.GRASP = TRUE}):

\describe{
\item{GRASP}{A \code{list} with \code{n.runs} components, each one containing also a \code{list} with two components:
\itemize{
\item{'par', containing the partition obtained by GRASP;}
\item{'tdv', with the value of TDV of the above partition.}
}
}
\item{SANN}{A \code{list} with \code{n.runs} components, each one containing also a \code{list} with six components:
\itemize{
\item{'par', containing the partition with highest value of TDV, obtained by the SANN algorithm;}
\item{'tdv', with the value of TDV of the above partition;}
\item{'current.tdv', a \code{vector} of length \code{n.iter} with the current TDV of each SANN iteration;}
\item{'alternative.tdv', a \code{vector} of length \code{n.iter} with the alternative TDV used in each SANN iteration;}
\item{'probability', a \code{vector} of length \code{n.iter} with the probability used in each SANN iteration;}
\item{'temperature', a \code{vector} of length \code{n.iter} with the temperature of each SANN iteration.}
}
}
}
}
\description{
This function searches for \code{k}-partitions of the columns of a given matrix (i.e. a partition of the columns in \code{k} groups), optimizing
the Total Differential Value (TDV) using a stochastic global optimization method called simulated annealing (SANN) algorithm. Optionally, a Greedy
Randomized Adaptive Search Procedure (GRASP) can be used to find a initial partition (seed) to be passed to the SANN algorithm.
}
\details{
Given a phytosociological table (\code{m}, with rows corresponding to taxa and columns corresponding to relevés) this function searches
for a k-partition (\code{k}, defined by the user) optimizing TDV, i.e. searches, using a SANN algorithm (optionally working upon GRASP solutions), for
the global maximum of TDV (by rearranging the relevés into \code{k} groups).

This function uses two main algorithms:
\enumerate{
\item An optional GRASP, which is used to obtain initial solutions (partitions of \code{m}) using function \code{\link{GRASP_partition_tdv}}. Such initial
solutions are then submitted to the SANN algorithm.
\item The (main) SANN algorithm, which is used to search for the global maximum of TDV. The initial partition for each run of SANN can be a partition
obtained from GRASP (if \code{use.GRASP = TRUE}) or, (if \code{use.GRASP = FALSE}), a partition given by the user (using \code{p.initial}) or a random partition
(using \code{p.initial = "random"}).
}

The SANN algorithm decreases the temperature multiplying the current temperature by \code{1 - alpha} according to a predefined schedule, which is
automatically calculated from the given values for \code{T_inic}, \code{T_final}, \code{alpha} and \code{n.iter}.
Specifically, the cooling schedule is obtained calculating the number of times that the temperature has to be decreased in order to
approximate \code{T_final} starting from \code{T_inic}. The number of times that the temperature decreases, say \code{nt}, is calculated by the
expression \code{floor(n.iter/((n.iter * log(1 - alpha)) / (log((1 - alpha) * T_final / T_inic))))}.
Finally, these decreasing stages are scattered through the desired iterations (\code{n.iter}) homogeneously, by calculating the indices of the
interactions that will experience a decreasing temperature, using the expression \code{floor(n.iter / nt * (1:nt))}.

SANN is often seen as an exploratory technique where the temperature settings are challenging and dependent on the problem. This function
tries to restrict temperature values taking into account that TDV is always between 0 and 1.
Even though, obtaining values of temperature that allow convergence can be challenging. \code{full.output = TRUE} allows the user to inspect the
behaviour of \code{current.tdv} and check if convergence fails.
Generally, convergence failure can be spotted when final SANN TDV values are similar to the initial \code{current.tdv}, specially when coming
from random partitions.
In such cases, as a rule of thumb, it is advisable to decrease \code{T_final}.
}
\author{
Jorge Orestes Cerdeira and Tiago Monteiro-Henriques. E-mail: \email{tiagomonteirohenriques@gmail.com}.
}
